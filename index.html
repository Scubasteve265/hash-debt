<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0a0a0a">
    <title>VIG</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Press Start 2P', monospace;
        }

        #game {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }

        canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            touch-action: none;
        }
    </style>
</head>
<body>
    <div id="game">
        <canvas id="canvas"></canvas>
    </div>

<script>
// ============================================================================
// VIG - Mine crypto. Pay sharks. Survive.
// Architecture based on Universal Paperclips + Shattered Pixel Dungeon patterns
// ============================================================================

(function() {
    'use strict';

    // ========================================================================
    // CONSTANTS
    // ========================================================================
    const COLORS = {
        bg: '#0a0a0a',
        bgLight: '#1a1a1a',
        primary: '#f7931a',      // VIG orange
        success: '#4ade80',      // Green
        danger: '#ef4444',       // Red
        warning: '#f59e0b',      // Yellow
        purple: '#8b5cf6',
        text: '#ffffff',
        textDim: '#666666',
        textMuted: '#333333'
    };

    const SHARKS = [
        { name: 'Vinnie', personality: 'patient', baseDemand: 30, interestMult: 1.1 },
        { name: 'Marco', personality: 'volatile', baseDemand: 50, interestMult: 1.2 },
        { name: 'Big Tony', personality: 'heavy', baseDemand: 80, interestMult: 1.15 },
        { name: 'The Butcher', personality: 'ruthless', baseDemand: 100, interestMult: 1.3 },
        { name: 'Sal', personality: 'slick', baseDemand: 60, interestMult: 1.25 },
        { name: 'Knuckles', personality: 'brute', baseDemand: 120, interestMult: 1.35 }
    ];

    // ========================================================================
    // GAME STATE
    // ========================================================================
    const GamePhase = {
        MENU: 'menu',
        MORNING: 'morning',
        MINING: 'mining',
        PAYDAY: 'payday',
        GAMEOVER: 'gameover'
    };

    const state = {
        phase: GamePhase.MENU,
        day: 1,

        // Currency
        cash: 50,
        cashDisplay: 50,  // For tweening
        vig: 0,
        vigDisplay: 0,

        // Mining state
        angle: 0,
        targetAngle: 0,
        targetSize: 0.15,
        spinSpeed: 0.04,
        isSpinning: false,

        // Block progress
        hashesFound: 0,
        hashesNeeded: 5,
        hashChance: 0.5,  // 50% chance per hit
        lastHash: '',
        lastHashValid: false,

        // Strikes
        strikes: 0,
        maxStrikes: 3,

        // Session
        sessionVig: 0,
        blocksMinedToday: 0,

        // Daily costs
        electricityCost: 10,
        rigDecay: 5,

        // Loan sharks
        sharks: [],

        // VIG market
        vigPrice: 100,  // $100 per VIG

        // Stats
        totalDaysSurvived: 0,
        totalBlocksMined: 0,
        highScore: 0,

        // UI
        buttons: [],
        message: null,
        messageTimer: 0
    };

    // ========================================================================
    // PARTICLE SYSTEM (Shattered Pixel Dungeon pattern)
    // ========================================================================
    class Emitter {
        constructor() {
            this.particles = [];
            this.x = 0;
            this.y = 0;
        }

        burst(x, y, color, count, speed = 100) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count + Math.random() * 0.5;
                const vel = speed * (0.5 + Math.random() * 0.5);
                this.particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * vel,
                    vy: Math.sin(angle) * vel,
                    size: 6 + Math.random() * 8,
                    color: color,
                    life: 0.5 + Math.random() * 0.3,
                    maxLife: 0.8,
                    gravity: 150
                });
            }
        }

        sparkUp(x, y, color, count) {
            for (let i = 0; i < count; i++) {
                this.particles.push({
                    x: x + (Math.random() - 0.5) * 40,
                    y: y,
                    vx: (Math.random() - 0.5) * 80,
                    vy: -150 - Math.random() * 150,
                    size: 5 + Math.random() * 6,
                    color: color,
                    life: 0.4 + Math.random() * 0.4,
                    maxLife: 0.8,
                    gravity: 50
                });
            }
        }

        update(dt) {
            this.particles = this.particles.filter(p => {
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.vy += p.gravity * dt;
                p.life -= dt;
                return p.life > 0;
            });
        }

        render(ctx) {
            this.particles.forEach(p => {
                const alpha = p.life / p.maxLife;
                const size = p.size * alpha;
                ctx.fillStyle = p.color;
                ctx.globalAlpha = alpha;
                // Pixel-style square particles
                ctx.fillRect(
                    Math.floor(p.x - size/2),
                    Math.floor(p.y - size/2),
                    Math.ceil(size),
                    Math.ceil(size)
                );
            });
            ctx.globalAlpha = 1;
        }
    }

    // ========================================================================
    // NUMBER TWEENING (Satisfying counter rolls)
    // ========================================================================
    class Tweener {
        static lerp(current, target, speed, dt) {
            const diff = target - current;
            if (Math.abs(diff) < 0.01) return target;
            return current + diff * Math.min(1, speed * dt);
        }
    }

    // ========================================================================
    // CAMERA / SCREEN SHAKE (SPD pattern)
    // ========================================================================
    const camera = {
        shakeX: 0,
        shakeY: 0,
        shakeMag: 0,
        shakeTime: 0,
        shakeDuration: 0,

        shake(magnitude, duration) {
            this.shakeMag = magnitude;
            this.shakeTime = duration;
            this.shakeDuration = duration;
        },

        update(dt) {
            if (this.shakeTime > 0) {
                const damping = this.shakeTime / this.shakeDuration;
                this.shakeX = (Math.random() - 0.5) * this.shakeMag * damping * 2;
                this.shakeY = (Math.random() - 0.5) * this.shakeMag * damping * 2;
                this.shakeTime -= dt;
            } else {
                this.shakeX = 0;
                this.shakeY = 0;
            }
        }
    };

    // ========================================================================
    // CANVAS SETUP
    // ========================================================================
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let W, H, scale, centerX, centerY, ringRadius;
    const emitter = new Emitter();

    function resize() {
        const container = document.getElementById('game');
        W = container.clientWidth;
        H = container.clientHeight;

        // Simple: canvas fills the screen
        canvas.width = W;
        canvas.height = H;
        canvas.style.width = '100%';
        canvas.style.height = '100%';

        centerX = W / 2;
        centerY = H * 0.38;
        ringRadius = Math.min(W, H) * 0.32;

        // Scale factor for UI elements (base on screen width)
        scale = Math.min(W / 400, H / 700) * 2;
        scale = Math.max(scale, 1.5); // Minimum scale

        // Disable anti-aliasing for pixel art
        ctx.imageSmoothingEnabled = false;
    }

    // ========================================================================
    // HASH GENERATION (Visual flavor)
    // ========================================================================
    function generateHash() {
        const chars = '0123456789ABCDEF';
        let hash = '';
        for (let i = 0; i < 8; i++) {
            hash += chars[Math.floor(Math.random() * chars.length)];
        }
        return hash;
    }

    function checkHashValid(day) {
        // Probability decreases with day
        const baseChance = state.hashChance - (day - 1) * 0.03;
        const chance = Math.max(0.15, baseChance);
        return Math.random() < chance;
    }

    // ========================================================================
    // SHARK MANAGEMENT
    // ========================================================================
    function addShark() {
        const available = SHARKS.filter(s =>
            !state.sharks.find(existing => existing.name === s.name)
        );
        if (available.length === 0) return null;

        const template = available[Math.floor(Math.random() * available.length)];
        const shark = {
            ...template,
            strikes: 0,
            demand: template.baseDemand,
            mood: 'neutral',  // neutral, warning, angry
            loanAmount: 100 + state.sharks.length * 50
        };
        state.sharks.push(shark);
        return shark;
    }

    function updateSharkDemands() {
        state.sharks.forEach(s => {
            s.demand = Math.floor(s.baseDemand * Math.pow(s.interestMult, state.day - 1));
        });
    }

    // ========================================================================
    // GAME LOGIC
    // ========================================================================
    function startGame() {
        state.phase = GamePhase.MORNING;
        state.day = 1;
        state.cash = 50;
        state.cashDisplay = 50;
        state.vig = 0;
        state.vigDisplay = 0;
        state.strikes = 0;
        state.sharks = [];
        state.sessionVig = 0;
        state.blocksMinedToday = 0;
        state.totalDaysSurvived = 0;
        state.totalBlocksMined = 0;
        state.vigPrice = 100;
        state.hashesFound = 0;
        state.hashesNeeded = 5;
        state.hashChance = 0.5;
        state.electricityCost = 10;
        state.rigDecay = 5;

        // Start with one shark
        addShark();

        showMorning();
    }

    function showMorning() {
        state.phase = GamePhase.MORNING;
        state.strikes = 0;
        state.sessionVig = 0;
        state.blocksMinedToday = 0;

        // Update difficulty
        state.hashesNeeded = Math.min(12, 5 + Math.floor((state.day - 1) / 2));
        state.hashChance = Math.max(0.2, 0.5 - (state.day - 1) * 0.025);
        state.spinSpeed = 0.04 + (state.day - 1) * 0.003;
        state.targetSize = Math.max(0.08, 0.15 - (state.day - 1) * 0.005);

        // Update costs
        state.electricityCost = 10 + (state.day - 1) * 3;
        state.rigDecay = 5 + (state.day - 1) * 2;

        // Update shark demands
        updateSharkDemands();

        // Update VIG price (random walk with slight downward bias)
        const priceChange = (Math.random() - 0.55) * 20;
        state.vigPrice = Math.max(30, state.vigPrice + priceChange);

        // Calculate total owed
        const totalOwed = state.sharks.reduce((sum, s) => sum + s.demand, 0);

        state.buttons = [
            {
                id: 'start_mining',
                text: 'START MINING',
                x: centerX,
                y: H * 0.85,
                w: 220 * scale,
                h: 55 * scale,
                color: COLORS.primary,
                action: startMining
            }
        ];
    }

    function startMining() {
        state.phase = GamePhase.MINING;
        state.isSpinning = true;
        state.angle = Math.random() * Math.PI * 2;
        state.targetAngle = Math.random() * Math.PI * 2;
        state.hashesFound = 0;
        state.lastHash = '';
        state.buttons = [];
    }

    function handleTap() {
        if (state.phase !== GamePhase.MINING || !state.isSpinning) return;

        state.isSpinning = false;

        // Check if in target zone
        const targetStart = state.targetAngle;
        const targetEnd = targetStart + (Math.PI * 2 * state.targetSize);

        let angle = state.angle % (Math.PI * 2);
        if (angle < 0) angle += Math.PI * 2;

        let inZone = false;
        if (targetEnd > Math.PI * 2) {
            // Zone wraps around
            inZone = angle >= targetStart || angle <= (targetEnd % (Math.PI * 2));
        } else {
            inZone = angle >= targetStart && angle <= targetEnd;
        }

        if (inZone) {
            onHit();
        } else {
            onMiss();
        }
    }

    function onHit() {
        // Generate hash and check if valid
        state.lastHash = generateHash();
        state.lastHashValid = checkHashValid(state.day);

        const hitX = centerX + Math.cos(state.angle) * ringRadius;
        const hitY = centerY + Math.sin(state.angle) * ringRadius;

        if (state.lastHashValid) {
            // Valid hash!
            state.hashesFound++;
            emitter.burst(hitX, hitY, COLORS.success, 15, 80);
            emitter.sparkUp(hitX, hitY, COLORS.primary, 8);
            showMessage('+1 HASH', COLORS.success);

            if (state.hashesFound >= state.hashesNeeded) {
                // Block cracked!
                crackBlock();
                return;
            }
        } else {
            // Invalid hash, but not a miss
            emitter.burst(hitX, hitY, COLORS.textDim, 8, 40);
            showMessage('INVALID', COLORS.textDim);
        }

        // Continue mining
        setTimeout(() => {
            if (state.phase === GamePhase.MINING) {
                state.isSpinning = true;
                state.targetAngle = Math.random() * Math.PI * 2;
            }
        }, 300);
    }

    function onMiss() {
        state.strikes++;
        camera.shake(15, 0.4);
        emitter.burst(centerX, centerY, COLORS.danger, 20, 120);
        showMessage('MISS!', COLORS.danger);

        if (state.strikes >= state.maxStrikes) {
            // Rig crashed, end day early
            setTimeout(() => endDay(true), 800);
        } else {
            setTimeout(() => {
                if (state.phase === GamePhase.MINING) {
                    state.isSpinning = true;
                    state.targetAngle = Math.random() * Math.PI * 2;
                }
            }, 500);
        }
    }

    function crackBlock() {
        // Block cracked!
        state.blocksMinedToday++;
        state.totalBlocksMined++;

        const vigEarned = 0.1 + Math.random() * 0.05;
        state.vig += vigEarned;
        state.sessionVig += vigEarned;

        camera.shake(8, 0.3);
        emitter.burst(centerX, centerY, COLORS.primary, 25, 150);
        emitter.sparkUp(centerX, centerY - 50, COLORS.success, 15);
        showMessage('BLOCK CRACKED!', COLORS.primary);

        // Show choice: continue or cash out
        setTimeout(() => {
            if (state.phase === GamePhase.MINING) {
                showMiningChoice();
            }
        }, 600);
    }

    function showMiningChoice() {
        state.isSpinning = false;
        state.buttons = [
            {
                id: 'cash_out',
                text: 'END DAY',
                x: centerX - 90 * scale,
                y: H * 0.78,
                w: 150 * scale,
                h: 50 * scale,
                color: COLORS.success,
                action: () => endDay(false)
            },
            {
                id: 'continue',
                text: 'CONTINUE',
                x: centerX + 90 * scale,
                y: H * 0.78,
                w: 150 * scale,
                h: 50 * scale,
                color: COLORS.purple,
                action: continueMining
            }
        ];
    }

    function continueMining() {
        state.buttons = [];
        state.hashesFound = 0;
        state.isSpinning = true;
        state.targetAngle = Math.random() * Math.PI * 2;
    }

    function endDay(crashed) {
        state.phase = GamePhase.PAYDAY;
        state.isSpinning = false;
        state.buttons = [];

        // Convert VIG to cash
        const cashEarned = state.sessionVig * state.vigPrice;
        state.cash += cashEarned;
        state.vig = 0;
        state.sessionVig = 0;

        // Deduct daily costs
        state.cash -= state.electricityCost;
        state.cash -= state.rigDecay;

        if (crashed) {
            showMessage('RIG CRASHED!', COLORS.danger);
        }

        setTimeout(() => showPayday(), crashed ? 1000 : 500);
    }

    function showPayday() {
        state.buttons = [];
        renderPayday();
    }

    function payShark(index) {
        const shark = state.sharks[index];
        if (state.cash >= shark.demand) {
            state.cash -= shark.demand;
            shark.mood = 'neutral';
            emitter.sparkUp(centerX, H * 0.5, COLORS.success, 10);
        }
        renderPayday();
    }

    function skipShark(index) {
        const shark = state.sharks[index];
        shark.strikes++;

        if (shark.strikes >= 3) {
            shark.mood = 'angry';
            gameOver(shark.name + ' COLLECTED');
            return;
        }

        shark.mood = shark.strikes >= 2 ? 'angry' : 'warning';
        camera.shake(5, 0.2);
        renderPayday();
    }

    function takeLoan() {
        const shark = addShark();
        if (shark) {
            state.cash += shark.loanAmount;
            emitter.sparkUp(centerX, H * 0.5, COLORS.primary, 15);
            showMessage('+$' + shark.loanAmount, COLORS.success);
        }
        renderPayday();
    }

    function nextDay() {
        state.day++;
        state.totalDaysSurvived++;
        showMorning();
    }

    function renderPayday() {
        // Build buttons for payday screen
        state.buttons = [];

        let y = H * 0.27;
        const cardH = 70 * scale;
        const cardW = W * 0.85;
        const btnH = 40 * scale;
        const btnW = 100 * scale;

        state.sharks.forEach((shark, i) => {
            const canPay = state.cash >= shark.demand;
            const paid = shark.mood === 'paid';
            const cardY = y + i * (cardH + 15 * scale);

            if (!paid) {
                // Buttons go below each card
                state.buttons.push({
                    id: 'pay_' + i,
                    text: 'PAY',
                    x: centerX - 60 * scale,
                    y: cardY + cardH + 25 * scale,
                    w: btnW,
                    h: btnH,
                    color: canPay ? COLORS.success : COLORS.textDim,
                    action: canPay ? () => payShark(i) : null
                });

                state.buttons.push({
                    id: 'skip_' + i,
                    text: 'SKIP',
                    x: centerX + 60 * scale,
                    y: cardY + cardH + 25 * scale,
                    w: btnW,
                    h: btnH,
                    color: COLORS.danger,
                    action: () => skipShark(i)
                });
            }
        });

        // Bottom buttons
        const bottomY = H * 0.88;

        // New loan button
        const hasAvailableSharks = state.sharks.length < SHARKS.length;
        if (hasAvailableSharks) {
            state.buttons.push({
                id: 'new_loan',
                text: '+ LOAN',
                x: centerX - 100 * scale,
                y: bottomY,
                w: 130 * scale,
                h: 45 * scale,
                color: COLORS.warning,
                action: takeLoan
            });
        }

        // Next day button
        state.buttons.push({
            id: 'next_day',
            text: 'NEXT DAY',
            x: hasAvailableSharks ? centerX + 100 * scale : centerX,
            y: bottomY,
            w: 160 * scale,
            h: 45 * scale,
            color: COLORS.primary,
            action: nextDay
        });
    }

    function gameOver(reason) {
        state.phase = GamePhase.GAMEOVER;
        state.buttons = [];

        // Update high score
        if (state.totalDaysSurvived > state.highScore) {
            state.highScore = state.totalDaysSurvived;
            localStorage.setItem('vig_highscore', state.highScore);
        }

        camera.shake(20, 0.5);

        setTimeout(() => {
            state.buttons = [{
                id: 'restart',
                text: 'TRY AGAIN',
                x: centerX,
                y: H * 0.80,
                w: 200 * scale,
                h: 55 * scale,
                color: COLORS.primary,
                action: startGame
            }];
        }, 1500);
    }

    function showMessage(text, color) {
        state.message = { text, color };
        state.messageTimer = 1.0;
    }

    // ========================================================================
    // INPUT HANDLING
    // ========================================================================
    function handleInput(x, y) {
        // Check buttons first
        for (const btn of state.buttons) {
            if (btn.action &&
                x >= btn.x - btn.w/2 && x <= btn.x + btn.w/2 &&
                y >= btn.y - btn.h/2 && y <= btn.y + btn.h/2) {
                btn.action();
                return;
            }
        }

        // Otherwise handle tap
        if (state.phase === GamePhase.MINING) {
            handleTap();
        }
    }

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const touch = e.touches[0];
        const x = (touch.clientX - rect.left) * (canvas.width / rect.width);
        const y = (touch.clientY - rect.top) * (canvas.height / rect.height);
        handleInput(x, y);
    }, { passive: false });

    canvas.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvas.width / rect.width);
        const y = (e.clientY - rect.top) * (canvas.height / rect.height);
        handleInput(x, y);
    });

    // ========================================================================
    // GAME LOOPS (Universal Paperclips pattern: separate update speeds)
    // ========================================================================
    let lastTime = 0;

    // Fast loop: Mining physics, particles (60fps)
    function fastUpdate(dt) {
        // Spin
        if (state.isSpinning) {
            state.angle += state.spinSpeed;
            if (state.angle > Math.PI * 2) state.angle -= Math.PI * 2;
        }

        // Particles
        emitter.update(dt);

        // Camera
        camera.update(dt);

        // Number tweening
        state.cashDisplay = Tweener.lerp(state.cashDisplay, state.cash, 8, dt);
        state.vigDisplay = Tweener.lerp(state.vigDisplay, state.vig, 8, dt);

        // Message timer
        if (state.messageTimer > 0) {
            state.messageTimer -= dt;
        }
    }

    // Render loop
    function render() {
        ctx.save();
        ctx.translate(Math.floor(camera.shakeX), Math.floor(camera.shakeY));

        // Clear
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(-10, -10, W + 20, H + 20);

        switch (state.phase) {
            case GamePhase.MENU:
                renderMenu();
                break;
            case GamePhase.MORNING:
                renderMorning();
                break;
            case GamePhase.MINING:
                renderMining();
                break;
            case GamePhase.PAYDAY:
                renderPaydayScreen();
                break;
            case GamePhase.GAMEOVER:
                renderGameOver();
                break;
        }

        // Render particles on top
        emitter.render(ctx);

        // Render message
        if (state.messageTimer > 0 && state.message) {
            const alpha = Math.min(1, state.messageTimer * 2);
            ctx.globalAlpha = alpha;
            ctx.fillStyle = state.message.color;
            ctx.font = `${20 * scale}px 'Press Start 2P'`;
            ctx.textAlign = 'center';
            ctx.fillText(state.message.text, centerX, centerY - ringRadius - 50 * scale);
            ctx.globalAlpha = 1;
        }

        ctx.restore();
    }

    function renderMenu() {
        // Title
        ctx.fillStyle = COLORS.primary;
        ctx.font = `${48 * scale}px 'Press Start 2P'`;
        ctx.textAlign = 'center';
        ctx.fillText('VIG', centerX, H * 0.3);

        // Subtitle
        ctx.fillStyle = COLORS.textDim;
        ctx.font = `${10 * scale}px 'Press Start 2P'`;
        ctx.fillText('MINE CRYPTO. PAY SHARKS.', centerX, H * 0.40);
        ctx.fillText('SURVIVE.', centerX, H * 0.45);

        // High score
        if (state.highScore > 0) {
            ctx.fillStyle = COLORS.purple;
            ctx.font = `${12 * scale}px 'Press Start 2P'`;
            ctx.fillText('BEST: ' + state.highScore + ' DAYS', centerX, H * 0.55);
        }

        // Start button
        renderButton({
            text: 'START',
            x: centerX,
            y: H * 0.70,
            w: 180 * scale,
            h: 60 * scale,
            color: COLORS.primary
        });

        state.buttons = [{
            id: 'start',
            text: 'START',
            x: centerX,
            y: H * 0.70,
            w: 180 * scale,
            h: 60 * scale,
            color: COLORS.primary,
            action: startGame
        }];
    }

    function renderMorning() {
        // Header
        ctx.fillStyle = COLORS.text;
        ctx.font = `${18 * scale}px 'Press Start 2P'`;
        ctx.textAlign = 'center';
        ctx.fillText('DAY ' + state.day, centerX, H * 0.08);

        // Cash
        ctx.fillStyle = COLORS.success;
        ctx.font = `${28 * scale}px 'Press Start 2P'`;
        ctx.fillText('$' + Math.floor(state.cashDisplay), centerX, H * 0.16);

        // Daily costs
        ctx.fillStyle = COLORS.textDim;
        ctx.font = `${11 * scale}px 'Press Start 2P'`;
        let y = H * 0.26;
        ctx.fillText('DAILY COSTS:', centerX, y);

        ctx.fillStyle = COLORS.danger;
        ctx.font = `${10 * scale}px 'Press Start 2P'`;
        y += 28 * scale;
        ctx.fillText('ELECTRICITY: -$' + state.electricityCost, centerX, y);
        y += 22 * scale;
        ctx.fillText('RIG DECAY: -$' + state.rigDecay, centerX, y);

        // Shark payments due
        y += 40 * scale;
        ctx.fillStyle = COLORS.textDim;
        ctx.font = `${11 * scale}px 'Press Start 2P'`;
        ctx.fillText('SHARKS WANT:', centerX, y);

        const totalOwed = state.sharks.reduce((sum, s) => sum + s.demand, 0);
        y += 28 * scale;
        ctx.fillStyle = COLORS.warning;
        ctx.font = `${22 * scale}px 'Press Start 2P'`;
        ctx.fillText('$' + totalOwed, centerX, y);

        // Mining info
        y += 50 * scale;
        ctx.fillStyle = COLORS.textDim;
        ctx.font = `${9 * scale}px 'Press Start 2P'`;
        ctx.fillText('HASH CHANCE: ' + Math.floor(state.hashChance * 100) + '%', centerX, y);
        y += 22 * scale;
        ctx.fillText('HASHES/BLOCK: ' + state.hashesNeeded, centerX, y);
        y += 22 * scale;
        ctx.fillText('VIG PRICE: $' + Math.floor(state.vigPrice), centerX, y);

        // Render buttons
        state.buttons.forEach(renderButton);
    }

    function renderMining() {
        // Header bar
        const headerY = 35 * scale;

        // Cash (left)
        ctx.fillStyle = COLORS.success;
        ctx.font = `${14 * scale}px 'Press Start 2P'`;
        ctx.textAlign = 'left';
        ctx.fillText('$' + Math.floor(state.cashDisplay), 20 * scale, headerY);

        // Day (center)
        ctx.fillStyle = COLORS.text;
        ctx.font = `${12 * scale}px 'Press Start 2P'`;
        ctx.textAlign = 'center';
        ctx.fillText('DAY ' + state.day, centerX, headerY);

        // VIG (right)
        ctx.fillStyle = COLORS.primary;
        ctx.font = `${14 * scale}px 'Press Start 2P'`;
        ctx.textAlign = 'right';
        ctx.fillText(state.vigDisplay.toFixed(2) + ' VIG', W - 20 * scale, headerY);

        // Strikes
        ctx.textAlign = 'center';
        ctx.fillStyle = COLORS.text;
        ctx.font = `${16 * scale}px 'Press Start 2P'`;
        let strikeText = '';
        for (let i = 0; i < state.maxStrikes; i++) {
            strikeText += i < state.strikes ? '✗ ' : '○ ';
        }
        ctx.fillText(strikeText, centerX, 65 * scale);

        // Draw pixel ring
        drawPixelRing(centerX, centerY, ringRadius, COLORS.bgLight, 12 * scale);

        // Draw target zone
        drawPixelArc(
            centerX, centerY, ringRadius,
            state.targetAngle,
            state.targetAngle + Math.PI * 2 * state.targetSize,
            COLORS.primary, 16 * scale
        );

        // Draw spinner
        if (state.phase === GamePhase.MINING) {
            const spinX = centerX + Math.cos(state.angle) * ringRadius;
            const spinY = centerY + Math.sin(state.angle) * ringRadius;

            // Trail
            for (let i = 1; i <= 5; i++) {
                const trailAngle = state.angle - i * 0.1;
                const tx = centerX + Math.cos(trailAngle) * ringRadius;
                const ty = centerY + Math.sin(trailAngle) * ringRadius;
                const size = (20 - i * 3) * scale;
                ctx.fillStyle = COLORS.text;
                ctx.globalAlpha = (5 - i) / 5 * 0.5;
                ctx.fillRect(
                    Math.floor(tx - size/2),
                    Math.floor(ty - size/2),
                    Math.ceil(size),
                    Math.ceil(size)
                );
            }
            ctx.globalAlpha = 1;

            // Main dot
            const dotSize = 24 * scale;
            ctx.fillStyle = COLORS.text;
            ctx.fillRect(
                Math.floor(spinX - dotSize/2),
                Math.floor(spinY - dotSize/2),
                Math.ceil(dotSize),
                Math.ceil(dotSize)
            );
        }

        // Hash progress
        const progressY = centerY + ringRadius + 50 * scale;
        ctx.fillStyle = COLORS.textDim;
        ctx.font = `${12 * scale}px 'Press Start 2P'`;
        ctx.textAlign = 'center';
        ctx.fillText('HASHES: ' + state.hashesFound + '/' + state.hashesNeeded, centerX, progressY);

        // Progress bar
        const barW = W * 0.7;
        const barH = 20 * scale;
        const barX = centerX - barW / 2;
        const barY = progressY + 15 * scale;

        ctx.fillStyle = COLORS.bgLight;
        ctx.fillRect(barX, barY, barW, barH);

        const progress = state.hashesFound / state.hashesNeeded;
        ctx.fillStyle = COLORS.primary;
        ctx.fillRect(barX, barY, barW * progress, barH);

        // Border
        ctx.strokeStyle = COLORS.textDim;
        ctx.lineWidth = 2;
        ctx.strokeRect(barX, barY, barW, barH);

        // Last hash
        if (state.lastHash) {
            ctx.fillStyle = state.lastHashValid ? COLORS.success : COLORS.textDim;
            ctx.font = `${11 * scale}px 'Press Start 2P'`;
            ctx.fillText(state.lastHash + (state.lastHashValid ? ' ✓' : ' ✗'), centerX, barY + barH + 30 * scale);
        }

        // Tap prompt
        if (state.isSpinning) {
            ctx.fillStyle = COLORS.textMuted;
            ctx.font = `${14 * scale}px 'Press Start 2P'`;
            ctx.fillText('TAP TO HASH', centerX, H * 0.90);
        }

        // Render buttons (for choice screen)
        state.buttons.forEach(renderButton);
    }

    function renderPaydayScreen() {
        // Header
        ctx.fillStyle = COLORS.warning;
        ctx.font = `${22 * scale}px 'Press Start 2P'`;
        ctx.textAlign = 'center';
        ctx.fillText('PAYDAY', centerX, H * 0.07);

        // Cash
        ctx.fillStyle = COLORS.success;
        ctx.font = `${28 * scale}px 'Press Start 2P'`;
        ctx.fillText('$' + Math.floor(state.cashDisplay), centerX, H * 0.14);

        // Blocks mined
        ctx.fillStyle = COLORS.textDim;
        ctx.font = `${10 * scale}px 'Press Start 2P'`;
        ctx.fillText('BLOCKS MINED: ' + state.blocksMinedToday, centerX, H * 0.20);

        // Sharks
        let y = H * 0.27;
        const cardH = 70 * scale;
        const cardW = W * 0.85;

        state.sharks.forEach((shark, i) => {
            const cardY = y + i * (cardH + 15 * scale);

            // Shark card background
            ctx.fillStyle = shark.mood === 'angry' ? '#2a1515' :
                           shark.mood === 'warning' ? '#2a2215' : '#1a1a1a';
            ctx.fillRect(centerX - cardW/2, cardY, cardW, cardH);

            // Border
            ctx.strokeStyle = shark.mood === 'angry' ? COLORS.danger :
                             shark.mood === 'warning' ? COLORS.warning : COLORS.textDim;
            ctx.lineWidth = 3;
            ctx.strokeRect(centerX - cardW/2, cardY, cardW, cardH);

            // Name
            ctx.fillStyle = COLORS.text;
            ctx.font = `${12 * scale}px 'Press Start 2P'`;
            ctx.textAlign = 'left';
            ctx.fillText(shark.name.toUpperCase(), centerX - cardW/2 + 15 * scale, cardY + 28 * scale);

            // Strikes
            let strikes = '';
            for (let j = 0; j < 3; j++) {
                strikes += j < shark.strikes ? '✗ ' : '○ ';
            }
            ctx.fillStyle = shark.strikes >= 2 ? COLORS.danger : COLORS.textDim;
            ctx.font = `${14 * scale}px 'Press Start 2P'`;
            ctx.fillText(strikes, centerX - cardW/2 + 15 * scale, cardY + 52 * scale);

            // Demand
            ctx.fillStyle = COLORS.success;
            ctx.font = `${16 * scale}px 'Press Start 2P'`;
            ctx.textAlign = 'right';
            ctx.fillText('$' + shark.demand, centerX + cardW/2 - 15 * scale, cardY + 40 * scale);
        });

        // Render buttons
        state.buttons.forEach(renderButton);
    }

    function renderGameOver() {
        ctx.fillStyle = COLORS.danger;
        ctx.font = `${32 * scale}px 'Press Start 2P'`;
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', centerX, H * 0.22);

        // Stats
        ctx.fillStyle = COLORS.text;
        ctx.font = `${14 * scale}px 'Press Start 2P'`;
        ctx.fillText('DAYS SURVIVED: ' + state.totalDaysSurvived, centerX, H * 0.38);
        ctx.fillText('BLOCKS MINED: ' + state.totalBlocksMined, centerX, H * 0.46);
        ctx.fillText('SHARKS FACED: ' + state.sharks.length, centerX, H * 0.54);

        // High score
        ctx.fillStyle = COLORS.purple;
        ctx.font = `${16 * scale}px 'Press Start 2P'`;
        ctx.fillText('BEST: ' + state.highScore + ' DAYS', centerX, H * 0.65);

        // Render buttons
        state.buttons.forEach(renderButton);
    }

    function renderButton(btn) {
        // Background
        ctx.fillStyle = btn.color || COLORS.primary;
        ctx.fillRect(btn.x - btn.w/2, btn.y - btn.h/2, btn.w, btn.h);

        // Border
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 3;
        ctx.strokeRect(btn.x - btn.w/2, btn.y - btn.h/2, btn.w, btn.h);

        // Text - size based on button height
        const fontSize = Math.max(8, Math.min(14, btn.h / 4));
        ctx.fillStyle = '#000';
        ctx.font = `${fontSize * scale}px 'Press Start 2P'`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(btn.text, btn.x, btn.y);
        ctx.textBaseline = 'alphabetic';
    }

    // ========================================================================
    // PIXEL DRAWING HELPERS
    // ========================================================================
    function drawPixelRing(cx, cy, radius, color, thickness) {
        ctx.strokeStyle = color;
        ctx.lineWidth = thickness;
        ctx.beginPath();

        // Draw as segmented for pixel feel
        const segments = 32;
        for (let i = 0; i <= segments; i++) {
            const a = (i / segments) * Math.PI * 2;
            const x = Math.floor(cx + Math.cos(a) * radius);
            const y = Math.floor(cy + Math.sin(a) * radius);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    }

    function drawPixelArc(cx, cy, radius, startAngle, endAngle, color, thickness) {
        ctx.strokeStyle = color;
        ctx.lineWidth = thickness;
        ctx.beginPath();

        const segments = Math.ceil(((endAngle - startAngle) / (Math.PI * 2)) * 32);
        for (let i = 0; i <= segments; i++) {
            const a = startAngle + (i / segments) * (endAngle - startAngle);
            const x = Math.floor(cx + Math.cos(a) * radius);
            const y = Math.floor(cy + Math.sin(a) * radius);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    }

    // ========================================================================
    // MAIN LOOP
    // ========================================================================
    function gameLoop(timestamp) {
        const dt = Math.min(0.1, (timestamp - lastTime) / 1000);
        lastTime = timestamp;

        fastUpdate(dt);
        render();

        requestAnimationFrame(gameLoop);
    }

    // ========================================================================
    // INIT
    // ========================================================================
    function init() {
        // Load high score
        state.highScore = parseInt(localStorage.getItem('vig_highscore') || '0');

        resize();
        window.addEventListener('resize', resize);

        state.phase = GamePhase.MENU;

        requestAnimationFrame(gameLoop);
    }

    init();
})();
</script>
</body>
</html>
