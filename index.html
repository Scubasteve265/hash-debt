<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0a0a0a">
    <title>VIG</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0a0a0a;
            font-family: 'Inter', sans-serif;
        }

        #game {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            touch-action: none;
        }
    </style>
</head>
<body>
    <div id="game">
        <canvas id="canvas"></canvas>
    </div>

<script>
(function() {
    'use strict';

    // ========================================================================
    // COLORS - Clean, modern, neon
    // ========================================================================
    const COLORS = {
        bg: '#0a0a0a',
        bgCard: '#141418',
        bgCardHover: '#1a1a20',
        primary: '#f7931a',      // VIG orange
        primaryGlow: 'rgba(247, 147, 26, 0.3)',
        success: '#10b981',
        successGlow: 'rgba(16, 185, 129, 0.3)',
        danger: '#ef4444',
        dangerGlow: 'rgba(239, 68, 68, 0.3)',
        warning: '#f59e0b',
        purple: '#8b5cf6',
        text: '#ffffff',
        textSecondary: '#a1a1aa',
        textMuted: '#52525b',
        border: '#27272a'
    };

    const SHARKS = [
        { name: 'Vinnie', baseDemand: 25, interestMult: 1.12 },
        { name: 'Marco', baseDemand: 40, interestMult: 1.18 },
        { name: 'Big Tony', baseDemand: 60, interestMult: 1.15 },
        { name: 'The Butcher', baseDemand: 80, interestMult: 1.25 },
        { name: 'Sal', baseDemand: 50, interestMult: 1.20 },
        { name: 'Knuckles', baseDemand: 100, interestMult: 1.30 }
    ];

    // ========================================================================
    // STATE
    // ========================================================================
    const GamePhase = {
        MENU: 'menu',
        MORNING: 'morning',
        MINING: 'mining',
        BLOCK_CRACKED: 'block_cracked',
        CRASHED: 'crashed',
        PAYDAY: 'payday',
        GAMEOVER: 'gameover'
    };

    const state = {
        phase: GamePhase.MENU,
        day: 1,
        cash: 0,
        cashDisplay: 0,
        vig: 0,

        // Ring
        angle: 0,
        targetAngle: 0,
        targetSize: 0.12,
        spinSpeed: 0.035,
        isSpinning: false,

        // Mining
        hashesFound: 0,
        hashesNeeded: 5,
        hashChance: 0.45,
        lastHash: '',
        lastHashValid: false,
        sessionVig: 0,
        blocksToday: 0,

        // Costs
        electricityCost: 8,
        rigCost: 4,

        // Sharks
        sharks: [],

        // Market
        vigPrice: 100,

        // Stats
        highScore: 0,

        // UI
        buttons: [],
        message: null,
        messageTimer: 0,
        flash: null,
        flashTimer: 0
    };

    // ========================================================================
    // PARTICLES
    // ========================================================================
    const particles = [];

    function spawnParticles(x, y, color, count, speed = 150) {
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 * i / count) + Math.random() * 0.3;
            const vel = speed * (0.6 + Math.random() * 0.4);
            particles.push({
                x, y,
                vx: Math.cos(angle) * vel,
                vy: Math.sin(angle) * vel,
                radius: 3 + Math.random() * 4,
                color,
                life: 1,
                decay: 1.5 + Math.random() * 0.5
            });
        }
    }

    function spawnRising(x, y, color, count) {
        for (let i = 0; i < count; i++) {
            particles.push({
                x: x + (Math.random() - 0.5) * 60,
                y,
                vx: (Math.random() - 0.5) * 30,
                vy: -120 - Math.random() * 80,
                radius: 3 + Math.random() * 3,
                color,
                life: 1,
                decay: 1.2
            });
        }
    }

    // ========================================================================
    // CAMERA
    // ========================================================================
    const camera = {
        shakeX: 0,
        shakeY: 0,
        shakeMag: 0,
        shakeTime: 0,

        shake(mag, time) {
            this.shakeMag = mag;
            this.shakeTime = time;
        },

        update(dt) {
            if (this.shakeTime > 0) {
                this.shakeTime -= dt;
                const intensity = this.shakeTime > 0 ? this.shakeMag : 0;
                this.shakeX = (Math.random() - 0.5) * intensity * 2;
                this.shakeY = (Math.random() - 0.5) * intensity * 2;
            } else {
                this.shakeX = 0;
                this.shakeY = 0;
            }
        }
    };

    // ========================================================================
    // CANVAS
    // ========================================================================
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let W, H, cx, cy, ringR;

    function resize() {
        W = window.innerWidth;
        H = window.innerHeight;
        canvas.width = W;
        canvas.height = H;

        cx = W / 2;
        cy = H * 0.38;
        ringR = Math.min(W * 0.38, H * 0.22);
    }

    // ========================================================================
    // HELPERS
    // ========================================================================
    function generateHash() {
        const chars = '0123456789ABCDEF';
        let h = '';
        for (let i = 0; i < 8; i++) h += chars[Math.floor(Math.random() * 16)];
        return h;
    }

    function lerp(a, b, t) {
        return a + (b - a) * Math.min(1, t);
    }

    function showMessage(text, color) {
        state.message = { text, color };
        state.messageTimer = 1.2;
    }

    function flash(color) {
        state.flash = color;
        state.flashTimer = 0.15;
    }

    // ========================================================================
    // SHARK LOGIC
    // ========================================================================
    function addShark() {
        const available = SHARKS.filter(s => !state.sharks.find(x => x.name === s.name));
        if (!available.length) return null;

        const template = available[Math.floor(Math.random() * available.length)];
        const shark = {
            ...template,
            strikes: 0,
            demand: template.baseDemand,
            loanAmount: 80 + state.sharks.length * 40
        };
        state.sharks.push(shark);
        return shark;
    }

    function updateSharkDemands() {
        state.sharks.forEach(s => {
            s.demand = Math.ceil(s.baseDemand * Math.pow(s.interestMult, state.day - 1));
        });
    }

    // ========================================================================
    // GAME FLOW
    // ========================================================================
    function startGame() {
        state.day = 1;
        state.cash = 40;
        state.cashDisplay = 40;
        state.vig = 0;
        state.sharks = [];
        state.sessionVig = 0;
        state.blocksToday = 0;
        state.vigPrice = 100;
        state.hashesNeeded = 5;
        state.hashChance = 0.45;
        state.electricityCost = 8;
        state.rigCost = 4;

        addShark();
        showMorning();
    }

    function showMorning() {
        state.phase = GamePhase.MORNING;
        state.sessionVig = 0;
        state.blocksToday = 0;

        // Scale difficulty
        state.hashesNeeded = Math.min(10, 5 + Math.floor(state.day / 3));
        state.hashChance = Math.max(0.25, 0.45 - state.day * 0.015);
        state.spinSpeed = Math.min(0.07, 0.035 + state.day * 0.002);
        state.targetSize = Math.max(0.08, 0.12 - state.day * 0.003);

        state.electricityCost = 8 + state.day * 2;
        state.rigCost = 4 + state.day;

        updateSharkDemands();

        // VIG price fluctuation
        state.vigPrice = Math.max(40, state.vigPrice + (Math.random() - 0.52) * 25);

        state.buttons = [{
            id: 'mine',
            text: 'START MINING',
            x: cx,
            y: H * 0.82,
            w: 220,
            h: 56,
            color: COLORS.primary,
            action: startMining
        }];
    }

    function startMining() {
        state.phase = GamePhase.MINING;
        state.isSpinning = true;
        state.hashesFound = 0;
        state.angle = Math.random() * Math.PI * 2;
        state.targetAngle = Math.random() * Math.PI * 2;
        state.lastHash = '';
        state.buttons = [];
    }

    function handleTap() {
        if (state.phase !== GamePhase.MINING || !state.isSpinning) return;

        state.isSpinning = false;

        // Check hit
        const tStart = state.targetAngle;
        const tEnd = tStart + Math.PI * 2 * state.targetSize;
        let a = state.angle % (Math.PI * 2);
        if (a < 0) a += Math.PI * 2;

        let hit = false;
        if (tEnd > Math.PI * 2) {
            hit = a >= tStart || a <= (tEnd % (Math.PI * 2));
        } else {
            hit = a >= tStart && a <= tEnd;
        }

        if (hit) {
            onHit();
        } else {
            onMiss();
        }
    }

    function onHit() {
        const hx = cx + Math.cos(state.angle) * ringR;
        const hy = cy + Math.sin(state.angle) * ringR;

        state.lastHash = generateHash();
        state.lastHashValid = Math.random() < state.hashChance;

        if (state.lastHashValid) {
            state.hashesFound++;
            spawnParticles(hx, hy, COLORS.success, 12, 100);
            flash(COLORS.successGlow);

            if (state.hashesFound >= state.hashesNeeded) {
                crackBlock();
                return;
            }
        } else {
            spawnParticles(hx, hy, COLORS.textMuted, 6, 50);
        }

        // Continue
        setTimeout(() => {
            if (state.phase === GamePhase.MINING) {
                state.isSpinning = true;
                state.targetAngle = Math.random() * Math.PI * 2;
            }
        }, 200);
    }

    function onMiss() {
        // ONE MISS = DONE
        state.phase = GamePhase.CRASHED;
        camera.shake(25, 0.5);
        flash(COLORS.dangerGlow);
        spawnParticles(cx, cy, COLORS.danger, 30, 200);
        showMessage('RIG CRASHED!', COLORS.danger);

        // Lose session earnings
        state.sessionVig = 0;

        setTimeout(() => {
            endDay();
        }, 1500);
    }

    function crackBlock() {
        state.phase = GamePhase.BLOCK_CRACKED;
        state.blocksToday++;

        const earned = 0.08 + Math.random() * 0.04;
        state.vig += earned;
        state.sessionVig += earned;

        camera.shake(10, 0.3);
        flash(COLORS.primaryGlow);
        spawnParticles(cx, cy, COLORS.primary, 20, 150);
        spawnRising(cx, cy - 30, COLORS.success, 10);
        showMessage('BLOCK CRACKED!', COLORS.primary);

        setTimeout(() => {
            state.buttons = [
                {
                    id: 'endday',
                    text: 'CASH OUT',
                    x: cx - 80,
                    y: H * 0.72,
                    w: 140,
                    h: 50,
                    color: COLORS.success,
                    action: endDay
                },
                {
                    id: 'continue',
                    text: 'KEEP GOING',
                    x: cx + 80,
                    y: H * 0.72,
                    w: 140,
                    h: 50,
                    color: COLORS.purple,
                    action: continuesMining
                }
            ];
        }, 600);
    }

    function continuesMining() {
        state.phase = GamePhase.MINING;
        state.isSpinning = true;
        state.hashesFound = 0;
        state.targetAngle = Math.random() * Math.PI * 2;
        state.buttons = [];
    }

    function endDay() {
        // Convert VIG to cash
        const earned = state.sessionVig * state.vigPrice;
        state.cash += earned;
        state.vig = 0;
        state.sessionVig = 0;

        // Deduct costs
        state.cash -= state.electricityCost;
        state.cash -= state.rigCost;
        state.cash = Math.max(0, state.cash);

        state.phase = GamePhase.PAYDAY;
        state.buttons = [];

        setTimeout(buildPaydayButtons, 300);
    }

    function buildPaydayButtons() {
        state.buttons = [];

        // Pay/skip buttons handled in render via tap detection

        const hasMore = state.sharks.length < SHARKS.length;

        if (hasMore) {
            state.buttons.push({
                id: 'loan',
                text: '+ NEW LOAN',
                x: cx,
                y: H * 0.78,
                w: 160,
                h: 48,
                color: COLORS.warning,
                action: () => {
                    const s = addShark();
                    if (s) {
                        state.cash += s.loanAmount;
                        spawnRising(cx, H * 0.5, COLORS.warning, 12);
                        showMessage('+$' + s.loanAmount, COLORS.success);
                        buildPaydayButtons();
                    }
                }
            });
        }

        state.buttons.push({
            id: 'next',
            text: 'NEXT DAY',
            x: cx,
            y: H * 0.88,
            w: 180,
            h: 52,
            color: COLORS.primary,
            action: () => {
                state.day++;
                showMorning();
            }
        });
    }

    function payShark(i) {
        const s = state.sharks[i];
        if (state.cash >= s.demand) {
            state.cash -= s.demand;
            s.paid = true;
            spawnRising(cx, H * 0.4, COLORS.success, 8);
        }
    }

    function skipShark(i) {
        const s = state.sharks[i];
        s.strikes++;
        s.paid = true;
        camera.shake(8, 0.2);

        if (s.strikes >= 3) {
            gameOver(s.name + ' collected.');
        }
    }

    function gameOver(reason) {
        state.phase = GamePhase.GAMEOVER;
        state.gameOverReason = reason;

        if (state.day > state.highScore) {
            state.highScore = state.day;
            localStorage.setItem('vig_hs', state.highScore);
        }

        camera.shake(30, 0.6);
        flash(COLORS.dangerGlow);

        setTimeout(() => {
            state.buttons = [{
                id: 'restart',
                text: 'TRY AGAIN',
                x: cx,
                y: H * 0.75,
                w: 180,
                h: 56,
                color: COLORS.primary,
                action: startGame
            }];
        }, 1000);
    }

    // ========================================================================
    // INPUT
    // ========================================================================
    function handleInput(x, y) {
        // Check buttons
        for (const b of state.buttons) {
            if (b.action && x >= b.x - b.w/2 && x <= b.x + b.w/2 && y >= b.y - b.h/2 && y <= b.y + b.h/2) {
                b.action();
                return;
            }
        }

        // Payday shark buttons
        if (state.phase === GamePhase.PAYDAY) {
            const cardW = W * 0.85;
            const cardH = 80;
            const startY = H * 0.22;

            state.sharks.forEach((s, i) => {
                if (s.paid) return;

                const cardY = startY + i * (cardH + 12);
                const btnY = cardY + cardH/2;
                const payX = cx + cardW/2 - 110;
                const skipX = cx + cardW/2 - 45;

                // Pay button
                if (x >= payX - 30 && x <= payX + 30 && y >= btnY - 18 && y <= btnY + 18) {
                    payShark(i);
                    return;
                }
                // Skip button
                if (x >= skipX - 25 && x <= skipX + 25 && y >= btnY - 18 && y <= btnY + 18) {
                    skipShark(i);
                    return;
                }
            });
        }

        // Mining tap
        if (state.phase === GamePhase.MINING) {
            handleTap();
        }
    }

    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        const t = e.touches[0];
        const r = canvas.getBoundingClientRect();
        handleInput(t.clientX - r.left, t.clientY - r.top);
    }, { passive: false });

    canvas.addEventListener('mousedown', e => {
        const r = canvas.getBoundingClientRect();
        handleInput(e.clientX - r.left, e.clientY - r.top);
    });

    // ========================================================================
    // UPDATE
    // ========================================================================
    let lastTime = 0;

    function update(dt) {
        // Spin
        if (state.isSpinning) {
            state.angle += state.spinSpeed;
        }

        // Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vy += 300 * dt;
            p.life -= p.decay * dt;
            if (p.life <= 0) particles.splice(i, 1);
        }

        // Camera
        camera.update(dt);

        // Tweens
        state.cashDisplay = lerp(state.cashDisplay, state.cash, dt * 10);

        // Message
        if (state.messageTimer > 0) state.messageTimer -= dt;

        // Flash
        if (state.flashTimer > 0) state.flashTimer -= dt;
    }

    // ========================================================================
    // RENDER
    // ========================================================================
    function render() {
        ctx.save();
        ctx.translate(camera.shakeX, camera.shakeY);

        // BG
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(-50, -50, W + 100, H + 100);

        // Flash
        if (state.flashTimer > 0 && state.flash) {
            ctx.fillStyle = state.flash;
            ctx.fillRect(0, 0, W, H);
        }

        switch (state.phase) {
            case GamePhase.MENU: renderMenu(); break;
            case GamePhase.MORNING: renderMorning(); break;
            case GamePhase.MINING:
            case GamePhase.BLOCK_CRACKED:
            case GamePhase.CRASHED:
                renderMining(); break;
            case GamePhase.PAYDAY: renderPayday(); break;
            case GamePhase.GAMEOVER: renderGameOver(); break;
        }

        // Particles
        particles.forEach(p => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius * p.life, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life;
            ctx.fill();
        });
        ctx.globalAlpha = 1;

        // Message
        if (state.messageTimer > 0 && state.message) {
            ctx.globalAlpha = Math.min(1, state.messageTimer * 2);
            ctx.font = '700 28px Orbitron';
            ctx.fillStyle = state.message.color;
            ctx.textAlign = 'center';
            ctx.fillText(state.message.text, cx, cy - ringR - 50);
            ctx.globalAlpha = 1;
        }

        // Buttons
        state.buttons.forEach(renderButton);

        ctx.restore();
    }

    function renderMenu() {
        // Title
        ctx.font = '900 64px Orbitron';
        ctx.fillStyle = COLORS.primary;
        ctx.textAlign = 'center';
        ctx.fillText('VIG', cx, H * 0.32);

        // Tagline
        ctx.font = '400 16px Inter';
        ctx.fillStyle = COLORS.textSecondary;
        ctx.fillText('Mine crypto. Pay sharks. Survive.', cx, H * 0.40);

        // High score
        if (state.highScore > 0) {
            ctx.font = '600 18px Inter';
            ctx.fillStyle = COLORS.purple;
            ctx.fillText('Best: ' + state.highScore + ' days', cx, H * 0.50);
        }

        // Warning
        ctx.font = '600 14px Inter';
        ctx.fillStyle = COLORS.danger;
        ctx.fillText('One miss and you\'re done.', cx, H * 0.58);
    }

    function renderMorning() {
        // Day
        ctx.font = '700 24px Orbitron';
        ctx.fillStyle = COLORS.text;
        ctx.textAlign = 'center';
        ctx.fillText('DAY ' + state.day, cx, H * 0.08);

        // Cash
        ctx.font = '900 42px Orbitron';
        ctx.fillStyle = COLORS.success;
        ctx.fillText('$' + Math.floor(state.cashDisplay), cx, H * 0.17);

        // Costs section
        ctx.font = '600 14px Inter';
        ctx.fillStyle = COLORS.textSecondary;
        ctx.fillText('DAILY COSTS', cx, H * 0.26);

        ctx.font = '400 16px Inter';
        ctx.fillStyle = COLORS.danger;
        ctx.fillText('Electricity: -$' + state.electricityCost, cx, H * 0.31);
        ctx.fillText('Rig decay: -$' + state.rigCost, cx, H * 0.36);

        // Sharks want
        const total = state.sharks.reduce((s, x) => s + x.demand, 0);
        ctx.font = '600 14px Inter';
        ctx.fillStyle = COLORS.textSecondary;
        ctx.fillText('SHARKS WANT', cx, H * 0.45);

        ctx.font = '700 32px Orbitron';
        ctx.fillStyle = COLORS.warning;
        ctx.fillText('$' + total, cx, H * 0.52);

        // Mining stats
        ctx.font = '400 13px Inter';
        ctx.fillStyle = COLORS.textMuted;
        ctx.fillText('Hash chance: ' + Math.floor(state.hashChance * 100) + '%  |  Hashes needed: ' + state.hashesNeeded, cx, H * 0.62);
        ctx.fillText('VIG price: $' + Math.floor(state.vigPrice), cx, H * 0.67);
    }

    function renderMining() {
        // Header
        ctx.font = '600 16px Inter';
        ctx.textAlign = 'left';
        ctx.fillStyle = COLORS.success;
        ctx.fillText('$' + Math.floor(state.cashDisplay), 20, 35);

        ctx.textAlign = 'center';
        ctx.fillStyle = COLORS.text;
        ctx.fillText('DAY ' + state.day, cx, 35);

        ctx.textAlign = 'right';
        ctx.fillStyle = COLORS.primary;
        ctx.fillText(state.sessionVig.toFixed(3) + ' VIG', W - 20, 35);

        // Ring glow
        ctx.beginPath();
        ctx.arc(cx, cy, ringR + 20, 0, Math.PI * 2);
        const glow = ctx.createRadialGradient(cx, cy, ringR - 10, cx, cy, ringR + 40);
        glow.addColorStop(0, 'transparent');
        glow.addColorStop(0.5, COLORS.primaryGlow);
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.fill();

        // Ring track
        ctx.beginPath();
        ctx.arc(cx, cy, ringR, 0, Math.PI * 2);
        ctx.strokeStyle = COLORS.border;
        ctx.lineWidth = 14;
        ctx.stroke();

        // Target zone
        ctx.beginPath();
        ctx.arc(cx, cy, ringR, state.targetAngle, state.targetAngle + Math.PI * 2 * state.targetSize);
        ctx.strokeStyle = COLORS.primary;
        ctx.lineWidth = 16;
        ctx.stroke();

        // Spinner
        const sx = cx + Math.cos(state.angle) * ringR;
        const sy = cy + Math.sin(state.angle) * ringR;

        // Trail
        for (let i = 1; i <= 6; i++) {
            const ta = state.angle - i * 0.08;
            const tx = cx + Math.cos(ta) * ringR;
            const ty = cy + Math.sin(ta) * ringR;
            ctx.beginPath();
            ctx.arc(tx, ty, 10 - i, 0, Math.PI * 2);
            ctx.fillStyle = COLORS.text;
            ctx.globalAlpha = (6 - i) / 6 * 0.4;
            ctx.fill();
        }
        ctx.globalAlpha = 1;

        // Main dot
        ctx.beginPath();
        ctx.arc(sx, sy, 12, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();

        // Progress
        const progY = cy + ringR + 50;
        ctx.font = '600 14px Inter';
        ctx.fillStyle = COLORS.textSecondary;
        ctx.textAlign = 'center';
        ctx.fillText('HASHES: ' + state.hashesFound + ' / ' + state.hashesNeeded, cx, progY);

        // Progress bar
        const barW = W * 0.7;
        const barH = 12;
        const barX = cx - barW / 2;
        const barY = progY + 15;

        ctx.fillStyle = COLORS.bgCard;
        ctx.fillRect(barX, barY, barW, barH);

        ctx.fillStyle = COLORS.primary;
        ctx.fillRect(barX, barY, barW * (state.hashesFound / state.hashesNeeded), barH);

        ctx.strokeStyle = COLORS.border;
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barW, barH);

        // Last hash
        if (state.lastHash) {
            ctx.font = '600 14px Inter';
            ctx.fillStyle = state.lastHashValid ? COLORS.success : COLORS.textMuted;
            ctx.fillText(state.lastHash + (state.lastHashValid ? ' ✓' : ''), cx, barY + 40);
        }

        // Tap prompt
        if (state.isSpinning) {
            ctx.font = '600 18px Inter';
            ctx.fillStyle = COLORS.textMuted;
            ctx.fillText('TAP TO HASH', cx, H * 0.88);
        }
    }

    function renderPayday() {
        // Header
        ctx.font = '700 28px Orbitron';
        ctx.fillStyle = COLORS.warning;
        ctx.textAlign = 'center';
        ctx.fillText('PAYDAY', cx, H * 0.06);

        // Cash
        ctx.font = '900 38px Orbitron';
        ctx.fillStyle = COLORS.success;
        ctx.fillText('$' + Math.floor(state.cashDisplay), cx, H * 0.13);

        // Blocks
        ctx.font = '400 14px Inter';
        ctx.fillStyle = COLORS.textSecondary;
        ctx.fillText('Blocks mined: ' + state.blocksToday, cx, H * 0.18);

        // Shark cards
        const cardW = W * 0.85;
        const cardH = 80;
        const startY = H * 0.22;

        state.sharks.forEach((s, i) => {
            const y = startY + i * (cardH + 12);

            // Card bg
            ctx.fillStyle = s.strikes >= 2 ? '#1a1215' : COLORS.bgCard;
            ctx.fillRect(cx - cardW/2, y, cardW, cardH);

            // Border
            ctx.strokeStyle = s.strikes >= 2 ? COLORS.danger : s.strikes >= 1 ? COLORS.warning : COLORS.border;
            ctx.lineWidth = 2;
            ctx.strokeRect(cx - cardW/2, y, cardW, cardH);

            // Name
            ctx.font = '700 16px Inter';
            ctx.fillStyle = COLORS.text;
            ctx.textAlign = 'left';
            ctx.fillText(s.name, cx - cardW/2 + 15, y + 30);

            // Strikes
            ctx.font = '400 14px Inter';
            ctx.fillStyle = s.strikes >= 2 ? COLORS.danger : COLORS.textMuted;
            let strikes = '';
            for (let j = 0; j < 3; j++) strikes += j < s.strikes ? '✗ ' : '○ ';
            ctx.fillText(strikes, cx - cardW/2 + 15, y + 55);

            // Demand
            ctx.font = '700 20px Orbitron';
            ctx.fillStyle = COLORS.success;
            ctx.textAlign = 'center';
            ctx.fillText('$' + s.demand, cx, y + 45);

            // Buttons (if not paid)
            if (!s.paid) {
                const btnY = y + cardH/2;
                const canPay = state.cash >= s.demand;

                // Pay
                ctx.fillStyle = canPay ? COLORS.success : COLORS.textMuted;
                ctx.fillRect(cx + cardW/2 - 140, btnY - 16, 60, 32);
                ctx.font = '700 12px Inter';
                ctx.fillStyle = '#000';
                ctx.textAlign = 'center';
                ctx.fillText('PAY', cx + cardW/2 - 110, btnY + 5);

                // Skip
                ctx.fillStyle = COLORS.danger;
                ctx.fillRect(cx + cardW/2 - 70, btnY - 16, 55, 32);
                ctx.fillStyle = '#000';
                ctx.fillText('SKIP', cx + cardW/2 - 42, btnY + 5);
            } else {
                ctx.font = '700 14px Inter';
                ctx.fillStyle = COLORS.textMuted;
                ctx.textAlign = 'right';
                ctx.fillText('DONE', cx + cardW/2 - 15, y + 45);
            }
        });
    }

    function renderGameOver() {
        ctx.font = '900 42px Orbitron';
        ctx.fillStyle = COLORS.danger;
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', cx, H * 0.25);

        ctx.font = '400 16px Inter';
        ctx.fillStyle = COLORS.textSecondary;
        ctx.fillText(state.gameOverReason || '', cx, H * 0.33);

        ctx.font = '700 20px Inter';
        ctx.fillStyle = COLORS.text;
        ctx.fillText('Days survived: ' + state.day, cx, H * 0.45);
        ctx.fillText('Blocks mined: ' + state.blocksToday, cx, H * 0.52);

        ctx.fillStyle = COLORS.purple;
        ctx.fillText('Best: ' + state.highScore + ' days', cx, H * 0.62);
    }

    function renderButton(b) {
        // Bg
        ctx.fillStyle = b.color;
        ctx.beginPath();
        ctx.roundRect(b.x - b.w/2, b.y - b.h/2, b.w, b.h, 8);
        ctx.fill();

        // Text
        ctx.font = '700 14px Inter';
        ctx.fillStyle = '#000';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(b.text, b.x, b.y);
        ctx.textBaseline = 'alphabetic';
    }

    // ========================================================================
    // LOOP
    // ========================================================================
    function loop(time) {
        const dt = Math.min(0.1, (time - lastTime) / 1000);
        lastTime = time;

        update(dt);
        render();

        requestAnimationFrame(loop);
    }

    // ========================================================================
    // INIT
    // ========================================================================
    state.highScore = parseInt(localStorage.getItem('vig_hs') || '0');
    resize();
    window.addEventListener('resize', resize);

    // Reset shark paid status each payday
    const origShowMorning = showMorning;
    showMorning = function() {
        state.sharks.forEach(s => s.paid = false);
        origShowMorning();
    };

    requestAnimationFrame(loop);
})();
</script>
</body>
</html>
